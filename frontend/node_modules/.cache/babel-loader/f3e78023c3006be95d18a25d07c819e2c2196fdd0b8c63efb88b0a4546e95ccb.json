{"ast":null,"code":"var _jsxFileName = \"/Users/marcolp/AI/CURSOR projects/Lose/frontend/src/context/BookContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport { useState, useEffect, createContext, useContext } from 'react';\nimport { bookService } from '../services/api';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst BookContext = /*#__PURE__*/createContext();\nexport const BookProvider = ({\n  children\n}) => {\n  _s();\n  const [books, setBooks] = useState([]);\n  const [isUploading, setIsUploading] = useState(false);\n  const [isGenerating, setIsGenerating] = useState(false);\n  useEffect(() => {\n    loadBooks();\n  }, []);\n  const loadBooks = async () => {\n    try {\n      const data = await bookService.getBooks();\n      setBooks(data);\n    } catch (error) {\n      console.error('Error loading books:', error);\n    }\n  };\n  const addBook = async bookData => {\n    try {\n      setIsUploading(true);\n      const response = await bookService.uploadBook(bookData.file);\n      setBooks(prevBooks => [...prevBooks, response.book]);\n      return response.book.id;\n    } catch (error) {\n      console.error('Error adding book:', error);\n      throw error;\n    } finally {\n      setIsUploading(false);\n    }\n  };\n  const removeBook = async bookId => {\n    try {\n      await bookService.deleteBook(bookId);\n      setBooks(prevBooks => prevBooks.filter(book => book.id !== bookId));\n    } catch (error) {\n      console.error('Error removing book:', error);\n      throw error;\n    }\n  };\n  const updateBook = async (bookId, updatedBook) => {\n    try {\n      const response = await bookService.updateBook(bookId, updatedBook);\n      setBooks(prevBooks => prevBooks.map(book => book.id === bookId ? response.book : book));\n    } catch (error) {\n      console.error('Error updating book:', error);\n      throw error;\n    }\n  };\n  const generateCategories = async bookId => {\n    try {\n      console.log('BookContext: Starting generateCategories for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generateCategories(bookId);\n      console.log('BookContext: Received categories response:', response);\n\n      // Aggiorniamo anche lo stato globale dei libri\n      setBooks(prevBooks => prevBooks.map(book => book.id === bookId ? {\n        ...book,\n        metadata: {\n          ...book.metadata,\n          categories: response\n        }\n      } : book));\n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating categories:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const generateKeywords = async bookId => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.generateKeywords(bookId);\n      return response;\n    } catch (error) {\n      console.error('Error generating keywords:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const regenerateCategory = async (bookId, type, currentCategories) => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.regenerateCategory(bookId, type, currentCategories);\n      return response;\n    } catch (error) {\n      console.error('Error regenerating category:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const regenerateKeyword = async (bookId, index, currentKeywords) => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.regenerateKeyword(bookId, index, currentKeywords);\n      return response;\n    } catch (error) {\n      console.error('Error regenerating keyword:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const generateScenes = async bookId => {\n    try {\n      console.log('BookContext: Starting generateScenes for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generateScenes(bookId);\n      console.log('BookContext: Received response from generateScenes:', response);\n      return response;\n    } catch (error) {\n      console.error('BookContext: Error in generateScenes:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const generateCoverImages = async (bookId, scenes) => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.generateCoverImages(bookId, scenes);\n      return response;\n    } catch (error) {\n      console.error('Error generating cover images:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const resetBookData = async bookId => {\n    try {\n      await bookService.resetBookData(bookId);\n      setBooks(prevBooks => prevBooks.map(book => {\n        if (book.id === bookId) {\n          // Rimuove metadata dal libro\n          const {\n            metadata,\n            ...restBook\n          } = book;\n          return {\n            ...restBook,\n            metadata: {\n              categories: {\n                mainCategory: null,\n                secondaryCategories: []\n              },\n              keywords: [],\n              covers: {\n                scenes: [],\n                selectedScene: null\n              },\n              backCover: null,\n              preface: null,\n              storeDescription: null\n            }\n          };\n        }\n        return book;\n      }));\n    } catch (error) {\n      console.error('Error resetting book data:', error);\n      throw error;\n    }\n  };\n  const generateBackCover = async bookId => {\n    try {\n      console.log('BookContext: Starting generateBackCover for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generateBackCover(bookId);\n      console.log('BookContext: Received back cover response:', response);\n\n      // Aggiorniamo lo stato globale preservando tutti i metadata esistenti\n      setBooks(prevBooks => prevBooks.map(book => {\n        if (book.id === bookId) {\n          return {\n            ...book,\n            metadata: {\n              ...book.metadata,\n              // Preserviamo tutti i metadata esistenti\n              categories: book.metadata.categories,\n              // Preserviamo esplicitamente le categorie\n              keywords: book.metadata.keywords,\n              // Preserviamo esplicitamente le keywords\n              covers: book.metadata.covers,\n              // Preserviamo esplicitamente le covers\n              backCover: response.backCover // Aggiungiamo la quarta\n            }\n          };\n        }\n        return book;\n      }));\n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating back cover:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const generatePreface = async bookId => {\n    try {\n      console.log('BookContext: Starting generatePreface for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generatePreface(bookId);\n      console.log('BookContext: Received preface response:', response);\n\n      // Aggiorniamo lo stato globale dei libri\n      setBooks(prevBooks => prevBooks.map(book => {\n        if (book.id === bookId) {\n          return {\n            ...book,\n            metadata: {\n              ...book.metadata,\n              categories: book.metadata.categories,\n              // Preserviamo le categorie\n              keywords: book.metadata.keywords,\n              // Preserviamo le keywords\n              covers: book.metadata.covers,\n              // Preserviamo le covers\n              backCover: book.metadata.backCover,\n              // Preserviamo la quarta\n              preface: response.preface // Aggiungiamo la prefazione\n            }\n          };\n        }\n        return book;\n      }));\n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating preface:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const generateStoreDescription = async bookId => {\n    try {\n      console.log('BookContext: Starting generateStoreDescription for bookId:', bookId);\n      console.log('BookContext: Current books state:', books);\n      setIsGenerating(true);\n      const response = await bookService.generateStoreDescription(bookId);\n      console.log('BookContext: Received store description response:', response);\n\n      // Aggiorniamo lo stato globale dei libri\n      setBooks(prevBooks => {\n        const updatedBooks = prevBooks.map(book => {\n          if (book.id === bookId) {\n            const updatedBook = {\n              ...book,\n              metadata: {\n                ...book.metadata,\n                categories: book.metadata.categories,\n                keywords: book.metadata.keywords,\n                covers: book.metadata.covers,\n                backCover: book.metadata.backCover,\n                preface: book.metadata.preface,\n                storeDescription: response.storeDescription\n              }\n            };\n            console.log('BookContext: Updated book:', updatedBook);\n            return updatedBook;\n          }\n          return book;\n        });\n        console.log('BookContext: Updated books state:', updatedBooks);\n        return updatedBooks;\n      });\n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating store description:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(BookContext.Provider, {\n    value: {\n      books,\n      setBooks,\n      addBook,\n      removeBook,\n      updateBook,\n      isUploading,\n      isGenerating,\n      generateCategories,\n      generateKeywords,\n      regenerateCategory,\n      regenerateKeyword,\n      generateScenes,\n      generateCoverImages,\n      resetBookData,\n      generateBackCover,\n      generatePreface,\n      generateStoreDescription\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 290,\n    columnNumber: 5\n  }, this);\n};\n_s(BookProvider, \"hycFg0zVUz7sw2uRqG3+zl7SP5s=\");\n_c = BookProvider;\nexport const useBooks = () => {\n  _s2();\n  return useContext(BookContext);\n};\n_s2(useBooks, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"BookProvider\");","map":{"version":3,"names":["useState","useEffect","createContext","useContext","bookService","jsxDEV","_jsxDEV","BookContext","BookProvider","children","_s","books","setBooks","isUploading","setIsUploading","isGenerating","setIsGenerating","loadBooks","data","getBooks","error","console","addBook","bookData","response","uploadBook","file","prevBooks","book","id","removeBook","bookId","deleteBook","filter","updateBook","updatedBook","map","generateCategories","log","metadata","categories","generateKeywords","regenerateCategory","type","currentCategories","regenerateKeyword","index","currentKeywords","generateScenes","generateCoverImages","scenes","resetBookData","restBook","mainCategory","secondaryCategories","keywords","covers","selectedScene","backCover","preface","storeDescription","generateBackCover","generatePreface","generateStoreDescription","updatedBooks","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useBooks","_s2","$RefreshReg$"],"sources":["/Users/marcolp/AI/CURSOR projects/Lose/frontend/src/context/BookContext.js"],"sourcesContent":["import { useState, useEffect, createContext, useContext } from 'react';\nimport { bookService } from '../services/api';\n\nconst BookContext = createContext();\n\nexport const BookProvider = ({ children }) => {\n  const [books, setBooks] = useState([]);\n  const [isUploading, setIsUploading] = useState(false);\n  const [isGenerating, setIsGenerating] = useState(false);\n\n  useEffect(() => {\n    loadBooks();\n  }, []);\n\n  const loadBooks = async () => {\n    try {\n      const data = await bookService.getBooks();\n      setBooks(data);\n    } catch (error) {\n      console.error('Error loading books:', error);\n    }\n  };\n\n  const addBook = async (bookData) => {\n    try {\n      setIsUploading(true);\n      const response = await bookService.uploadBook(bookData.file);\n      setBooks(prevBooks => [...prevBooks, response.book]);\n      return response.book.id;\n    } catch (error) {\n      console.error('Error adding book:', error);\n      throw error;\n    } finally {\n      setIsUploading(false);\n    }\n  };\n\n  const removeBook = async (bookId) => {\n    try {\n      await bookService.deleteBook(bookId);\n      setBooks(prevBooks => prevBooks.filter(book => book.id !== bookId));\n    } catch (error) {\n      console.error('Error removing book:', error);\n      throw error;\n    }\n  };\n\n  const updateBook = async (bookId, updatedBook) => {\n    try {\n      const response = await bookService.updateBook(bookId, updatedBook);\n      setBooks(prevBooks => \n        prevBooks.map(book => \n          book.id === bookId ? response.book : book\n        )\n      );\n    } catch (error) {\n      console.error('Error updating book:', error);\n      throw error;\n    }\n  };\n\n  const generateCategories = async (bookId) => {\n    try {\n      console.log('BookContext: Starting generateCategories for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generateCategories(bookId);\n      console.log('BookContext: Received categories response:', response);\n      \n      // Aggiorniamo anche lo stato globale dei libri\n      setBooks(prevBooks => prevBooks.map(book => \n        book.id === bookId \n          ? { ...book, metadata: { ...book.metadata, categories: response } }\n          : book\n      ));\n      \n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating categories:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const generateKeywords = async (bookId) => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.generateKeywords(bookId);\n      return response;\n    } catch (error) {\n      console.error('Error generating keywords:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const regenerateCategory = async (bookId, type, currentCategories) => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.regenerateCategory(bookId, type, currentCategories);\n      return response;\n    } catch (error) {\n      console.error('Error regenerating category:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const regenerateKeyword = async (bookId, index, currentKeywords) => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.regenerateKeyword(bookId, index, currentKeywords);\n      return response;\n    } catch (error) {\n      console.error('Error regenerating keyword:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const generateScenes = async (bookId) => {\n    try {\n      console.log('BookContext: Starting generateScenes for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generateScenes(bookId);\n      console.log('BookContext: Received response from generateScenes:', response);\n      return response;\n    } catch (error) {\n      console.error('BookContext: Error in generateScenes:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const generateCoverImages = async (bookId, scenes) => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.generateCoverImages(bookId, scenes);\n      return response;\n    } catch (error) {\n      console.error('Error generating cover images:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const resetBookData = async (bookId) => {\n    try {\n      await bookService.resetBookData(bookId);\n      setBooks(prevBooks => prevBooks.map(book => {\n        if (book.id === bookId) {\n          // Rimuove metadata dal libro\n          const { metadata, ...restBook } = book;\n          return {\n            ...restBook,\n            metadata: {\n              categories: { mainCategory: null, secondaryCategories: [] },\n              keywords: [],\n              covers: { scenes: [], selectedScene: null },\n              backCover: null,\n              preface: null,\n              storeDescription: null\n            }\n          };\n        }\n        return book;\n      }));\n    } catch (error) {\n      console.error('Error resetting book data:', error);\n      throw error;\n    }\n  };\n\n  const generateBackCover = async (bookId) => {\n    try {\n      console.log('BookContext: Starting generateBackCover for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generateBackCover(bookId);\n      console.log('BookContext: Received back cover response:', response);\n      \n      // Aggiorniamo lo stato globale preservando tutti i metadata esistenti\n      setBooks(prevBooks => prevBooks.map(book => {\n        if (book.id === bookId) {\n          return {\n            ...book,\n            metadata: {\n              ...book.metadata,  // Preserviamo tutti i metadata esistenti\n              categories: book.metadata.categories,  // Preserviamo esplicitamente le categorie\n              keywords: book.metadata.keywords,      // Preserviamo esplicitamente le keywords\n              covers: book.metadata.covers,          // Preserviamo esplicitamente le covers\n              backCover: response.backCover          // Aggiungiamo la quarta\n            }\n          };\n        }\n        return book;\n      }));\n      \n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating back cover:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const generatePreface = async (bookId) => {\n    try {\n      console.log('BookContext: Starting generatePreface for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generatePreface(bookId);\n      console.log('BookContext: Received preface response:', response);\n      \n      // Aggiorniamo lo stato globale dei libri\n      setBooks(prevBooks => prevBooks.map(book => {\n        if (book.id === bookId) {\n          return {\n            ...book,\n            metadata: {\n              ...book.metadata,\n              categories: book.metadata.categories,  // Preserviamo le categorie\n              keywords: book.metadata.keywords,      // Preserviamo le keywords\n              covers: book.metadata.covers,          // Preserviamo le covers\n              backCover: book.metadata.backCover,    // Preserviamo la quarta\n              preface: response.preface             // Aggiungiamo la prefazione\n            }\n          };\n        }\n        return book;\n      }));\n      \n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating preface:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const generateStoreDescription = async (bookId) => {\n    try {\n      console.log('BookContext: Starting generateStoreDescription for bookId:', bookId);\n      console.log('BookContext: Current books state:', books);\n      setIsGenerating(true);\n      \n      const response = await bookService.generateStoreDescription(bookId);\n      console.log('BookContext: Received store description response:', response);\n      \n      // Aggiorniamo lo stato globale dei libri\n      setBooks(prevBooks => {\n        const updatedBooks = prevBooks.map(book => {\n          if (book.id === bookId) {\n            const updatedBook = {\n              ...book,\n              metadata: {\n                ...book.metadata,\n                categories: book.metadata.categories,\n                keywords: book.metadata.keywords,\n                covers: book.metadata.covers,\n                backCover: book.metadata.backCover,\n                preface: book.metadata.preface,\n                storeDescription: response.storeDescription\n              }\n            };\n            console.log('BookContext: Updated book:', updatedBook);\n            return updatedBook;\n          }\n          return book;\n        });\n        console.log('BookContext: Updated books state:', updatedBooks);\n        return updatedBooks;\n      });\n      \n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating store description:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  return (\n    <BookContext.Provider value={{ \n      books, \n      setBooks, \n      addBook, \n      removeBook, \n      updateBook,\n      isUploading,\n      isGenerating,\n      generateCategories,\n      generateKeywords,\n      regenerateCategory,\n      regenerateKeyword,\n      generateScenes,\n      generateCoverImages,\n      resetBookData,\n      generateBackCover,\n      generatePreface,\n      generateStoreDescription,\n    }}>\n      {children}\n    </BookContext.Provider>\n  );\n};\n\nexport const useBooks = () => useContext(BookContext); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}