{"ast":null,"code":"var _jsxFileName = \"/Users/marcolp/AI/CURSOR projects/Lose/frontend/src/context/BookContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport { useState, useEffect, createContext, useContext } from 'react';\nimport { bookService } from '../services/api';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst BookContext = /*#__PURE__*/createContext();\nexport const BookProvider = ({\n  children\n}) => {\n  _s();\n  const [books, setBooks] = useState([]);\n  const [isUploading, setIsUploading] = useState(false);\n  const [isGenerating, setIsGenerating] = useState(false);\n  useEffect(() => {\n    loadBooks();\n  }, []);\n  const loadBooks = async () => {\n    try {\n      const data = await bookService.getBooks();\n      setBooks(data);\n    } catch (error) {\n      console.error('Error loading books:', error);\n    }\n  };\n  const addBook = async bookData => {\n    try {\n      setIsUploading(true);\n      const response = await bookService.uploadBook(bookData.file);\n      setBooks(prevBooks => [...prevBooks, response.book]);\n      return response.book.id;\n    } catch (error) {\n      console.error('Error adding book:', error);\n      throw error;\n    } finally {\n      setIsUploading(false);\n    }\n  };\n  const removeBook = async bookId => {\n    try {\n      await bookService.deleteBook(bookId);\n      setBooks(prevBooks => prevBooks.filter(book => book.id !== bookId));\n    } catch (error) {\n      console.error('Error removing book:', error);\n      throw error;\n    }\n  };\n  const updateBook = async (bookId, updatedBook) => {\n    try {\n      const response = await bookService.updateBook(bookId, updatedBook);\n      setBooks(prevBooks => prevBooks.map(book => book.id === bookId ? response.book : book));\n    } catch (error) {\n      console.error('Error updating book:', error);\n      throw error;\n    }\n  };\n  const generateCategories = async bookId => {\n    try {\n      console.log('BookContext: Starting generateCategories for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generateCategories(bookId);\n      console.log('BookContext: Received categories response:', response);\n\n      // Aggiorniamo anche lo stato globale dei libri\n      setBooks(prevBooks => prevBooks.map(book => book.id === bookId ? {\n        ...book,\n        metadata: {\n          ...book.metadata,\n          categories: response\n        }\n      } : book));\n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating categories:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const generateKeywords = async bookId => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.generateKeywords(bookId);\n      return response;\n    } catch (error) {\n      console.error('Error generating keywords:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const regenerateCategory = async (bookId, type, currentCategories) => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.regenerateCategory(bookId, type, currentCategories);\n      return response;\n    } catch (error) {\n      console.error('Error regenerating category:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const regenerateKeyword = async (bookId, index, currentKeywords) => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.regenerateKeyword(bookId, index, currentKeywords);\n\n      // Aggiorniamo lo stato con le nuove keywords\n      setBooks(prevBooks => prevBooks.map(book => {\n        if (book.id === bookId) {\n          return {\n            ...book,\n            metadata: {\n              ...book.metadata,\n              keywords: response.keywords // Qui response.keywords è già un array di stringhe\n            }\n          };\n        }\n        return book;\n      }));\n      return response;\n    } catch (error) {\n      console.error('Error regenerating keyword:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const generateScenes = async bookId => {\n    try {\n      console.log('BookContext: Starting generateScenes for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generateScenes(bookId);\n      console.log('BookContext: Received response from generateScenes:', response);\n      return response;\n    } catch (error) {\n      console.error('BookContext: Error in generateScenes:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const generateCoverImages = async (bookId, scenes) => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.generateCoverImages(bookId, scenes);\n      return response;\n    } catch (error) {\n      console.error('Error generating cover images:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const resetBookData = async bookId => {\n    try {\n      await bookService.resetBookData(bookId);\n      setBooks(prevBooks => {\n        return prevBooks.map(book => {\n          if (book.id === bookId) {\n            return {\n              ...book,\n              metadata: {\n                categories: null,\n                keywords: null,\n                covers: null,\n                backCover: null,\n                preface: null,\n                storeDescription: null\n              }\n            };\n          }\n          return book;\n        });\n      });\n    } catch (error) {\n      console.error('Error resetting book data:', error);\n      throw error;\n    }\n  };\n  const generateBackCover = async bookId => {\n    try {\n      console.log('BookContext: Starting generateBackCover for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generateBackCover(bookId);\n      console.log('BookContext: Received back cover response:', response);\n\n      // Aggiorniamo lo stato globale preservando tutti i metadata esistenti\n      setBooks(prevBooks => prevBooks.map(book => {\n        if (book.id === bookId) {\n          return {\n            ...book,\n            metadata: {\n              ...book.metadata,\n              // Preserviamo tutti i metadata esistenti\n              categories: book.metadata.categories,\n              // Preserviamo esplicitamente le categorie\n              keywords: book.metadata.keywords,\n              // Preserviamo esplicitamente le keywords\n              covers: book.metadata.covers,\n              // Preserviamo esplicitamente le covers\n              backCover: response.backCover // Aggiungiamo la quarta\n            }\n          };\n        }\n        return book;\n      }));\n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating back cover:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const generatePreface = async bookId => {\n    try {\n      console.log('BookContext: Starting generatePreface for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generatePreface(bookId);\n      console.log('BookContext: Received preface response:', response);\n\n      // Aggiorniamo lo stato globale dei libri\n      setBooks(prevBooks => prevBooks.map(book => {\n        if (book.id === bookId) {\n          return {\n            ...book,\n            metadata: {\n              ...book.metadata,\n              categories: book.metadata.categories,\n              // Preserviamo le categorie\n              keywords: book.metadata.keywords,\n              // Preserviamo le keywords\n              covers: book.metadata.covers,\n              // Preserviamo le covers\n              backCover: book.metadata.backCover,\n              // Preserviamo la quarta\n              preface: response.preface // Aggiungiamo la prefazione\n            }\n          };\n        }\n        return book;\n      }));\n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating preface:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const generateStoreDescription = async bookId => {\n    try {\n      console.log('BookContext: Starting generateStoreDescription for bookId:', bookId);\n      console.log('BookContext: Current books state:', books);\n      setIsGenerating(true);\n      const response = await bookService.generateStoreDescription(bookId);\n      console.log('BookContext: Received store description response:', response);\n\n      // Aggiorniamo lo stato globale dei libri\n      setBooks(prevBooks => {\n        const updatedBooks = prevBooks.map(book => {\n          if (book.id === bookId) {\n            const updatedBook = {\n              ...book,\n              metadata: {\n                ...book.metadata,\n                categories: book.metadata.categories,\n                keywords: book.metadata.keywords,\n                covers: book.metadata.covers,\n                backCover: book.metadata.backCover,\n                preface: book.metadata.preface,\n                storeDescription: response.storeDescription\n              }\n            };\n            console.log('BookContext: Updated book:', updatedBook);\n            return updatedBook;\n          }\n          return book;\n        });\n        console.log('BookContext: Updated books state:', updatedBooks);\n        return updatedBooks;\n      });\n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating store description:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const updateBookMetadata = (bookId, updates) => {\n    setBooks(prevBooks => {\n      return prevBooks.map(book => {\n        if (book.id === bookId) {\n          return {\n            ...book,\n            metadata: {\n              ...book.metadata,\n              // Preserva i metadata esistenti\n              ...updates // Aggiunge/aggiorna solo i campi specificati\n            }\n          };\n        }\n        return book;\n      });\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(BookContext.Provider, {\n    value: {\n      books,\n      setBooks,\n      addBook,\n      removeBook,\n      updateBook,\n      isUploading,\n      isGenerating,\n      generateCategories,\n      generateKeywords,\n      regenerateCategory,\n      regenerateKeyword,\n      generateScenes,\n      generateCoverImages,\n      resetBookData,\n      generateBackCover,\n      generatePreface,\n      generateStoreDescription,\n      updateBookMetadata\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 322,\n    columnNumber: 5\n  }, this);\n};\n_s(BookProvider, \"hycFg0zVUz7sw2uRqG3+zl7SP5s=\");\n_c = BookProvider;\nexport const useBooks = () => {\n  _s2();\n  return useContext(BookContext);\n};\n_s2(useBooks, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"BookProvider\");","map":{"version":3,"names":["useState","useEffect","createContext","useContext","bookService","jsxDEV","_jsxDEV","BookContext","BookProvider","children","_s","books","setBooks","isUploading","setIsUploading","isGenerating","setIsGenerating","loadBooks","data","getBooks","error","console","addBook","bookData","response","uploadBook","file","prevBooks","book","id","removeBook","bookId","deleteBook","filter","updateBook","updatedBook","map","generateCategories","log","metadata","categories","generateKeywords","regenerateCategory","type","currentCategories","regenerateKeyword","index","currentKeywords","keywords","generateScenes","generateCoverImages","scenes","resetBookData","covers","backCover","preface","storeDescription","generateBackCover","generatePreface","generateStoreDescription","updatedBooks","updateBookMetadata","updates","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useBooks","_s2","$RefreshReg$"],"sources":["/Users/marcolp/AI/CURSOR projects/Lose/frontend/src/context/BookContext.js"],"sourcesContent":["import { useState, useEffect, createContext, useContext } from 'react';\nimport { bookService } from '../services/api';\n\nconst BookContext = createContext();\n\nexport const BookProvider = ({ children }) => {\n  const [books, setBooks] = useState([]);\n  const [isUploading, setIsUploading] = useState(false);\n  const [isGenerating, setIsGenerating] = useState(false);\n\n  useEffect(() => {\n    loadBooks();\n  }, []);\n\n  const loadBooks = async () => {\n    try {\n      const data = await bookService.getBooks();\n      setBooks(data);\n    } catch (error) {\n      console.error('Error loading books:', error);\n    }\n  };\n\n  const addBook = async (bookData) => {\n    try {\n      setIsUploading(true);\n      const response = await bookService.uploadBook(bookData.file);\n      setBooks(prevBooks => [...prevBooks, response.book]);\n      return response.book.id;\n    } catch (error) {\n      console.error('Error adding book:', error);\n      throw error;\n    } finally {\n      setIsUploading(false);\n    }\n  };\n\n  const removeBook = async (bookId) => {\n    try {\n      await bookService.deleteBook(bookId);\n      setBooks(prevBooks => prevBooks.filter(book => book.id !== bookId));\n    } catch (error) {\n      console.error('Error removing book:', error);\n      throw error;\n    }\n  };\n\n  const updateBook = async (bookId, updatedBook) => {\n    try {\n      const response = await bookService.updateBook(bookId, updatedBook);\n      setBooks(prevBooks => \n        prevBooks.map(book => \n          book.id === bookId ? response.book : book\n        )\n      );\n    } catch (error) {\n      console.error('Error updating book:', error);\n      throw error;\n    }\n  };\n\n  const generateCategories = async (bookId) => {\n    try {\n      console.log('BookContext: Starting generateCategories for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generateCategories(bookId);\n      console.log('BookContext: Received categories response:', response);\n      \n      // Aggiorniamo anche lo stato globale dei libri\n      setBooks(prevBooks => prevBooks.map(book => \n        book.id === bookId \n          ? { ...book, metadata: { ...book.metadata, categories: response } }\n          : book\n      ));\n      \n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating categories:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const generateKeywords = async (bookId) => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.generateKeywords(bookId);\n      return response;\n    } catch (error) {\n      console.error('Error generating keywords:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const regenerateCategory = async (bookId, type, currentCategories) => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.regenerateCategory(bookId, type, currentCategories);\n      return response;\n    } catch (error) {\n      console.error('Error regenerating category:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const regenerateKeyword = async (bookId, index, currentKeywords) => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.regenerateKeyword(bookId, index, currentKeywords);\n      \n      // Aggiorniamo lo stato con le nuove keywords\n      setBooks(prevBooks => prevBooks.map(book => {\n        if (book.id === bookId) {\n          return {\n            ...book,\n            metadata: {\n              ...book.metadata,\n              keywords: response.keywords // Qui response.keywords è già un array di stringhe\n            }\n          };\n        }\n        return book;\n      }));\n      \n      return response;\n    } catch (error) {\n      console.error('Error regenerating keyword:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const generateScenes = async (bookId) => {\n    try {\n      console.log('BookContext: Starting generateScenes for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generateScenes(bookId);\n      console.log('BookContext: Received response from generateScenes:', response);\n      return response;\n    } catch (error) {\n      console.error('BookContext: Error in generateScenes:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const generateCoverImages = async (bookId, scenes) => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.generateCoverImages(bookId, scenes);\n      return response;\n    } catch (error) {\n      console.error('Error generating cover images:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const resetBookData = async (bookId) => {\n    try {\n      await bookService.resetBookData(bookId);\n      setBooks(prevBooks => {\n        return prevBooks.map(book => {\n          if (book.id === bookId) {\n            return {\n              ...book,\n              metadata: {\n                categories: null,\n                keywords: null,\n                covers: null,\n                backCover: null,\n                preface: null,\n                storeDescription: null\n              }\n            };\n          }\n          return book;\n        });\n      });\n    } catch (error) {\n      console.error('Error resetting book data:', error);\n      throw error;\n    }\n  };\n\n  const generateBackCover = async (bookId) => {\n    try {\n      console.log('BookContext: Starting generateBackCover for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generateBackCover(bookId);\n      console.log('BookContext: Received back cover response:', response);\n      \n      // Aggiorniamo lo stato globale preservando tutti i metadata esistenti\n      setBooks(prevBooks => prevBooks.map(book => {\n        if (book.id === bookId) {\n          return {\n            ...book,\n            metadata: {\n              ...book.metadata,  // Preserviamo tutti i metadata esistenti\n              categories: book.metadata.categories,  // Preserviamo esplicitamente le categorie\n              keywords: book.metadata.keywords,      // Preserviamo esplicitamente le keywords\n              covers: book.metadata.covers,          // Preserviamo esplicitamente le covers\n              backCover: response.backCover          // Aggiungiamo la quarta\n            }\n          };\n        }\n        return book;\n      }));\n      \n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating back cover:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const generatePreface = async (bookId) => {\n    try {\n      console.log('BookContext: Starting generatePreface for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generatePreface(bookId);\n      console.log('BookContext: Received preface response:', response);\n      \n      // Aggiorniamo lo stato globale dei libri\n      setBooks(prevBooks => prevBooks.map(book => {\n        if (book.id === bookId) {\n          return {\n            ...book,\n            metadata: {\n              ...book.metadata,\n              categories: book.metadata.categories,  // Preserviamo le categorie\n              keywords: book.metadata.keywords,      // Preserviamo le keywords\n              covers: book.metadata.covers,          // Preserviamo le covers\n              backCover: book.metadata.backCover,    // Preserviamo la quarta\n              preface: response.preface             // Aggiungiamo la prefazione\n            }\n          };\n        }\n        return book;\n      }));\n      \n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating preface:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const generateStoreDescription = async (bookId) => {\n    try {\n      console.log('BookContext: Starting generateStoreDescription for bookId:', bookId);\n      console.log('BookContext: Current books state:', books);\n      setIsGenerating(true);\n      \n      const response = await bookService.generateStoreDescription(bookId);\n      console.log('BookContext: Received store description response:', response);\n      \n      // Aggiorniamo lo stato globale dei libri\n      setBooks(prevBooks => {\n        const updatedBooks = prevBooks.map(book => {\n          if (book.id === bookId) {\n            const updatedBook = {\n              ...book,\n              metadata: {\n                ...book.metadata,\n                categories: book.metadata.categories,\n                keywords: book.metadata.keywords,\n                covers: book.metadata.covers,\n                backCover: book.metadata.backCover,\n                preface: book.metadata.preface,\n                storeDescription: response.storeDescription\n              }\n            };\n            console.log('BookContext: Updated book:', updatedBook);\n            return updatedBook;\n          }\n          return book;\n        });\n        console.log('BookContext: Updated books state:', updatedBooks);\n        return updatedBooks;\n      });\n      \n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating store description:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const updateBookMetadata = (bookId, updates) => {\n    setBooks(prevBooks => {\n      return prevBooks.map(book => {\n        if (book.id === bookId) {\n          return {\n            ...book,\n            metadata: {\n              ...book.metadata,  // Preserva i metadata esistenti\n              ...updates        // Aggiunge/aggiorna solo i campi specificati\n            }\n          };\n        }\n        return book;\n      });\n    });\n  };\n\n  return (\n    <BookContext.Provider value={{ \n      books, \n      setBooks, \n      addBook, \n      removeBook, \n      updateBook,\n      isUploading,\n      isGenerating,\n      generateCategories,\n      generateKeywords,\n      regenerateCategory,\n      regenerateKeyword,\n      generateScenes,\n      generateCoverImages,\n      resetBookData,\n      generateBackCover,\n      generatePreface,\n      generateStoreDescription,\n      updateBookMetadata,\n    }}>\n      {children}\n    </BookContext.Provider>\n  );\n};\n\nexport const useBooks = () => useContext(BookContext); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}