{"ast":null,"code":"var _jsxFileName = \"/Users/marcolp/AI/CURSOR projects/Lose/frontend/src/context/BookContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport { useState, useEffect, createContext, useContext } from 'react';\nimport { bookService } from '../services/api';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst BookContext = /*#__PURE__*/createContext();\nexport const BookProvider = ({\n  children\n}) => {\n  _s();\n  const [books, setBooks] = useState([]);\n  const [isUploading, setIsUploading] = useState(false);\n  const [isGenerating, setIsGenerating] = useState(false);\n  const [isAnyTaskGenerating, setIsAnyTaskGenerating] = useState(false);\n  useEffect(() => {\n    loadBooks();\n  }, []);\n  const loadBooks = async () => {\n    try {\n      const data = await bookService.getBooks();\n      setBooks(data || []);\n    } catch (error) {\n      if (error.response && error.response.status === 404) {\n        setBooks([]);\n        return;\n      }\n      console.error('Error loading books:', error);\n    }\n  };\n  const addBook = async bookData => {\n    try {\n      setIsUploading(true);\n      const response = await bookService.uploadBook(bookData.file);\n      setBooks(prevBooks => [...prevBooks, response.book]);\n      return response.book.id;\n    } catch (error) {\n      console.error('Error adding book:', error);\n      throw error;\n    } finally {\n      setIsUploading(false);\n    }\n  };\n  const removeBook = async bookId => {\n    try {\n      await bookService.deleteBook(bookId);\n      setBooks(prevBooks => prevBooks.filter(book => book.id !== bookId));\n    } catch (error) {\n      console.error('Error removing book:', error);\n      throw error;\n    }\n  };\n  const updateBook = async (bookId, updatedBook) => {\n    try {\n      const response = await bookService.updateBook(bookId, updatedBook);\n      setBooks(prevBooks => prevBooks.map(book => book.id === bookId ? response.book : book));\n    } catch (error) {\n      console.error('Error updating book:', error);\n      throw error;\n    }\n  };\n  const generateCategories = async bookId => {\n    try {\n      console.log('BookContext: Starting generateCategories for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generateCategories(bookId);\n      console.log('BookContext: Received categories response:', response);\n\n      // Aggiorniamo anche lo stato globale dei libri\n      setBooks(prevBooks => prevBooks.map(book => book.id === bookId ? {\n        ...book,\n        metadata: {\n          ...book.metadata,\n          categories: response\n        }\n      } : book));\n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating categories:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const generateKeywords = async bookId => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.generateKeywords(bookId);\n      return response;\n    } catch (error) {\n      console.error('Error generating keywords:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const generateScenes = async bookId => {\n    try {\n      console.log('BookContext: Starting generateScenes for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generateScenes(bookId);\n      console.log('BookContext: Received response from generateScenes:', response);\n      return response;\n    } catch (error) {\n      console.error('BookContext: Error in generateScenes:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const generateCoverImages = async (bookId, scenes) => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.generateCoverImages(bookId, scenes);\n      return response;\n    } catch (error) {\n      console.error('Error generating cover images:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const resetBookData = async bookId => {\n    try {\n      await bookService.resetBookData(bookId);\n      setBooks(prevBooks => {\n        return prevBooks.map(book => {\n          if (book.id === bookId) {\n            return {\n              ...book,\n              metadata: {\n                categories: null,\n                keywords: null,\n                covers: null,\n                backCover: null,\n                preface: null,\n                storeDescription: null\n              }\n            };\n          }\n          return book;\n        });\n      });\n    } catch (error) {\n      console.error('Error resetting book data:', error);\n      throw error;\n    }\n  };\n  const generateBackCover = async bookId => {\n    try {\n      console.log('BookContext: Starting generateBackCover for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generateBackCover(bookId);\n      console.log('BookContext: Received back cover response:', response);\n\n      // Aggiorniamo lo stato globale preservando tutti i metadata esistenti\n      setBooks(prevBooks => prevBooks.map(book => {\n        if (book.id === bookId) {\n          return {\n            ...book,\n            metadata: {\n              ...book.metadata,\n              // Preserviamo tutti i metadata esistenti\n              categories: book.metadata.categories,\n              // Preserviamo esplicitamente le categorie\n              keywords: book.metadata.keywords,\n              // Preserviamo esplicitamente le keywords\n              covers: book.metadata.covers,\n              // Preserviamo esplicitamente le covers\n              backCover: response.backCover // Aggiungiamo la quarta\n            }\n          };\n        }\n        return book;\n      }));\n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating back cover:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const generatePreface = async bookId => {\n    try {\n      console.log('BookContext: Starting generatePreface for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generatePreface(bookId);\n      console.log('BookContext: Received preface response:', response);\n\n      // Aggiorniamo lo stato globale dei libri\n      setBooks(prevBooks => prevBooks.map(book => {\n        if (book.id === bookId) {\n          return {\n            ...book,\n            metadata: {\n              ...book.metadata,\n              categories: book.metadata.categories,\n              // Preserviamo le categorie\n              keywords: book.metadata.keywords,\n              // Preserviamo le keywords\n              covers: book.metadata.covers,\n              // Preserviamo le covers\n              backCover: book.metadata.backCover,\n              // Preserviamo la quarta\n              preface: response.preface // Aggiungiamo la prefazione\n            }\n          };\n        }\n        return book;\n      }));\n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating preface:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const generateStoreDescription = async bookId => {\n    try {\n      console.log('BookContext: Starting generateStoreDescription for bookId:', bookId);\n      console.log('BookContext: Current books state:', books);\n      setIsGenerating(true);\n      const response = await bookService.generateStoreDescription(bookId);\n      console.log('BookContext: Received store description response:', response);\n\n      // Aggiorniamo lo stato globale dei libri\n      setBooks(prevBooks => {\n        const updatedBooks = prevBooks.map(book => {\n          if (book.id === bookId) {\n            const updatedBook = {\n              ...book,\n              metadata: {\n                ...book.metadata,\n                categories: book.metadata.categories,\n                keywords: book.metadata.keywords,\n                covers: book.metadata.covers,\n                backCover: book.metadata.backCover,\n                preface: book.metadata.preface,\n                storeDescription: response.storeDescription\n              }\n            };\n            console.log('BookContext: Updated book:', updatedBook);\n            return updatedBook;\n          }\n          return book;\n        });\n        console.log('BookContext: Updated books state:', updatedBooks);\n        return updatedBooks;\n      });\n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating store description:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  const updateBookMetadata = (bookId, updates) => {\n    setBooks(prevBooks => {\n      return prevBooks.map(book => {\n        if (book.id === bookId) {\n          return {\n            ...book,\n            metadata: {\n              ...book.metadata,\n              // Preserva i metadata esistenti\n              ...updates // Aggiunge/aggiorna solo i campi specificati\n            }\n          };\n        }\n        return book;\n      });\n    });\n  };\n  const generateSynopsis = async bookId => {\n    try {\n      const result = await bookService.generateSynopsis(bookId);\n      setBooks(prevBooks => prevBooks.map(book => book.id === bookId ? {\n        ...book,\n        metadata: {\n          ...book.metadata,\n          synopsis: result.synopsis\n        }\n      } : book));\n      return result;\n    } catch (error) {\n      console.error('Error generating synopsis:', error);\n      throw error;\n    }\n  };\n  const value = {\n    books,\n    setBooks,\n    addBook,\n    removeBook,\n    updateBook,\n    isUploading,\n    isGenerating,\n    generateCategories,\n    generateKeywords,\n    generateScenes,\n    generateCoverImages,\n    resetBookData,\n    generateBackCover,\n    generatePreface,\n    generateStoreDescription,\n    updateBookMetadata,\n    isAnyTaskGenerating,\n    setIsAnyTaskGenerating,\n    generateSynopsis\n  };\n  return /*#__PURE__*/_jsxDEV(BookContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 325,\n    columnNumber: 5\n  }, this);\n};\n_s(BookProvider, \"RW/x1BbvqyOJ2XArmahBo1Kp4pY=\");\n_c = BookProvider;\nexport const useBooks = () => {\n  _s2();\n  return useContext(BookContext);\n};\n_s2(useBooks, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"BookProvider\");","map":{"version":3,"names":["useState","useEffect","createContext","useContext","bookService","jsxDEV","_jsxDEV","BookContext","BookProvider","children","_s","books","setBooks","isUploading","setIsUploading","isGenerating","setIsGenerating","isAnyTaskGenerating","setIsAnyTaskGenerating","loadBooks","data","getBooks","error","response","status","console","addBook","bookData","uploadBook","file","prevBooks","book","id","removeBook","bookId","deleteBook","filter","updateBook","updatedBook","map","generateCategories","log","metadata","categories","generateKeywords","generateScenes","generateCoverImages","scenes","resetBookData","keywords","covers","backCover","preface","storeDescription","generateBackCover","generatePreface","generateStoreDescription","updatedBooks","updateBookMetadata","updates","generateSynopsis","result","synopsis","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useBooks","_s2","$RefreshReg$"],"sources":["/Users/marcolp/AI/CURSOR projects/Lose/frontend/src/context/BookContext.js"],"sourcesContent":["import { useState, useEffect, createContext, useContext } from 'react';\nimport { bookService } from '../services/api';\n\nconst BookContext = createContext();\n\nexport const BookProvider = ({ children }) => {\n  const [books, setBooks] = useState([]);\n  const [isUploading, setIsUploading] = useState(false);\n  const [isGenerating, setIsGenerating] = useState(false);\n  const [isAnyTaskGenerating, setIsAnyTaskGenerating] = useState(false);\n\n  useEffect(() => {\n    loadBooks();\n  }, []);\n\n  const loadBooks = async () => {\n    try {\n      const data = await bookService.getBooks();\n      setBooks(data || []);\n    } catch (error) {\n      if (error.response && error.response.status === 404) {\n        setBooks([]);\n        return;\n      }\n      console.error('Error loading books:', error);\n    }\n  };\n\n  const addBook = async (bookData) => {\n    try {\n      setIsUploading(true);\n      const response = await bookService.uploadBook(bookData.file);\n      setBooks(prevBooks => [...prevBooks, response.book]);\n      return response.book.id;\n    } catch (error) {\n      console.error('Error adding book:', error);\n      throw error;\n    } finally {\n      setIsUploading(false);\n    }\n  };\n\n  const removeBook = async (bookId) => {\n    try {\n      await bookService.deleteBook(bookId);\n      setBooks(prevBooks => prevBooks.filter(book => book.id !== bookId));\n    } catch (error) {\n      console.error('Error removing book:', error);\n      throw error;\n    }\n  };\n\n  const updateBook = async (bookId, updatedBook) => {\n    try {\n      const response = await bookService.updateBook(bookId, updatedBook);\n      setBooks(prevBooks => \n        prevBooks.map(book => \n          book.id === bookId ? response.book : book\n        )\n      );\n    } catch (error) {\n      console.error('Error updating book:', error);\n      throw error;\n    }\n  };\n\n  const generateCategories = async (bookId) => {\n    try {\n      console.log('BookContext: Starting generateCategories for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generateCategories(bookId);\n      console.log('BookContext: Received categories response:', response);\n      \n      // Aggiorniamo anche lo stato globale dei libri\n      setBooks(prevBooks => prevBooks.map(book => \n        book.id === bookId \n          ? { ...book, metadata: { ...book.metadata, categories: response } }\n          : book\n      ));\n      \n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating categories:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const generateKeywords = async (bookId) => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.generateKeywords(bookId);\n      return response;\n    } catch (error) {\n      console.error('Error generating keywords:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const generateScenes = async (bookId) => {\n    try {\n      console.log('BookContext: Starting generateScenes for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generateScenes(bookId);\n      console.log('BookContext: Received response from generateScenes:', response);\n      return response;\n    } catch (error) {\n      console.error('BookContext: Error in generateScenes:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const generateCoverImages = async (bookId, scenes) => {\n    try {\n      setIsGenerating(true);\n      const response = await bookService.generateCoverImages(bookId, scenes);\n      return response;\n    } catch (error) {\n      console.error('Error generating cover images:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const resetBookData = async (bookId) => {\n    try {\n      await bookService.resetBookData(bookId);\n      setBooks(prevBooks => {\n        return prevBooks.map(book => {\n          if (book.id === bookId) {\n            return {\n              ...book,\n              metadata: {\n                categories: null,\n                keywords: null,\n                covers: null,\n                backCover: null,\n                preface: null,\n                storeDescription: null\n              }\n            };\n          }\n          return book;\n        });\n      });\n    } catch (error) {\n      console.error('Error resetting book data:', error);\n      throw error;\n    }\n  };\n\n  const generateBackCover = async (bookId) => {\n    try {\n      console.log('BookContext: Starting generateBackCover for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generateBackCover(bookId);\n      console.log('BookContext: Received back cover response:', response);\n      \n      // Aggiorniamo lo stato globale preservando tutti i metadata esistenti\n      setBooks(prevBooks => prevBooks.map(book => {\n        if (book.id === bookId) {\n          return {\n            ...book,\n            metadata: {\n              ...book.metadata,  // Preserviamo tutti i metadata esistenti\n              categories: book.metadata.categories,  // Preserviamo esplicitamente le categorie\n              keywords: book.metadata.keywords,      // Preserviamo esplicitamente le keywords\n              covers: book.metadata.covers,          // Preserviamo esplicitamente le covers\n              backCover: response.backCover          // Aggiungiamo la quarta\n            }\n          };\n        }\n        return book;\n      }));\n      \n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating back cover:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const generatePreface = async (bookId) => {\n    try {\n      console.log('BookContext: Starting generatePreface for bookId:', bookId);\n      setIsGenerating(true);\n      const response = await bookService.generatePreface(bookId);\n      console.log('BookContext: Received preface response:', response);\n      \n      // Aggiorniamo lo stato globale dei libri\n      setBooks(prevBooks => prevBooks.map(book => {\n        if (book.id === bookId) {\n          return {\n            ...book,\n            metadata: {\n              ...book.metadata,\n              categories: book.metadata.categories,  // Preserviamo le categorie\n              keywords: book.metadata.keywords,      // Preserviamo le keywords\n              covers: book.metadata.covers,          // Preserviamo le covers\n              backCover: book.metadata.backCover,    // Preserviamo la quarta\n              preface: response.preface             // Aggiungiamo la prefazione\n            }\n          };\n        }\n        return book;\n      }));\n      \n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating preface:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const generateStoreDescription = async (bookId) => {\n    try {\n      console.log('BookContext: Starting generateStoreDescription for bookId:', bookId);\n      console.log('BookContext: Current books state:', books);\n      setIsGenerating(true);\n      \n      const response = await bookService.generateStoreDescription(bookId);\n      console.log('BookContext: Received store description response:', response);\n      \n      // Aggiorniamo lo stato globale dei libri\n      setBooks(prevBooks => {\n        const updatedBooks = prevBooks.map(book => {\n          if (book.id === bookId) {\n            const updatedBook = {\n              ...book,\n              metadata: {\n                ...book.metadata,\n                categories: book.metadata.categories,\n                keywords: book.metadata.keywords,\n                covers: book.metadata.covers,\n                backCover: book.metadata.backCover,\n                preface: book.metadata.preface,\n                storeDescription: response.storeDescription\n              }\n            };\n            console.log('BookContext: Updated book:', updatedBook);\n            return updatedBook;\n          }\n          return book;\n        });\n        console.log('BookContext: Updated books state:', updatedBooks);\n        return updatedBooks;\n      });\n      \n      return response;\n    } catch (error) {\n      console.error('BookContext: Error generating store description:', error);\n      throw error;\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const updateBookMetadata = (bookId, updates) => {\n    setBooks(prevBooks => {\n      return prevBooks.map(book => {\n        if (book.id === bookId) {\n          return {\n            ...book,\n            metadata: {\n              ...book.metadata,  // Preserva i metadata esistenti\n              ...updates        // Aggiunge/aggiorna solo i campi specificati\n            }\n          };\n        }\n        return book;\n      });\n    });\n  };\n\n  const generateSynopsis = async (bookId) => {\n    try {\n      const result = await bookService.generateSynopsis(bookId);\n      setBooks(prevBooks => \n        prevBooks.map(book => \n          book.id === bookId \n            ? { ...book, metadata: { ...book.metadata, synopsis: result.synopsis } }\n            : book\n        )\n      );\n      return result;\n    } catch (error) {\n      console.error('Error generating synopsis:', error);\n      throw error;\n    }\n  };\n\n  const value = {\n    books, \n    setBooks, \n    addBook, \n    removeBook, \n    updateBook,\n    isUploading,\n    isGenerating,\n    generateCategories,\n    generateKeywords,\n    generateScenes,\n    generateCoverImages,\n    resetBookData,\n    generateBackCover,\n    generatePreface,\n    generateStoreDescription,\n    updateBookMetadata,\n    isAnyTaskGenerating,\n    setIsAnyTaskGenerating,\n    generateSynopsis,\n  };\n\n  return (\n    <BookContext.Provider value={value}>\n      {children}\n    </BookContext.Provider>\n  );\n};\n\nexport const useBooks = () => useContext(BookContext); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}